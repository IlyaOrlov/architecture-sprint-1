# Задание 1

## Уровень 1.

1. Предварительный анализ.
   - **Оценка сложности и масштаба приложения.** Приложение небольшое, но сложное для модификации и развёртывания:
      + App.js находится в сильном зацеплении с остальными компонентами: в его коде описываются обработчики для компонентов. При необходимости изменить поведение отдельного компонента (форм входа/регистрации, профиля пользователя, карточки места) с большой вероятностью придётся менять и код конкретного компонента, и общий код в App.js.
      + Присутствуют неиспользуемые (возможно, потерянные) элементы интерфейса: `<PopupWithForm title="Вы уверены?" name="remove-card" buttonText="Да" />` в App.js
      + Все функции для взаимодействия с бэкендом расположены в двух файлах api.js и auth.js с привязкой к общему URL. Это затрудняет возможность масштабирования приложения под конкретную нагрузку.
      + Стили компонентов, реализующих разные бизнес-функции, привязаны к единому файлу стилей: popup.css включает как стили общих элементов для этих компонентов, т.к. и специфические, которые нужны только отдельным компонентам. При необходимости изменить стиль отдельного компонента могут быть непреднамеренно затронуты и стили других компонентов.

   - **Формулировка цели перехода.** Необходимо, чтобы "в будущем проект могли развивать несколько независимых команд". Для этого требуется разбить фронтенда проекта на микрофронтенды, которые могли бы модифицироваться и разворачиваться независимо друг от друга.

   - **Оценка опыта команды.** "Команда" имеет одинаковый уровень экспертизы в React, Vue и Angular.

2. Определение бизнес-функций, которыми будут заниматься разные команды.
   - Загрузка фотографий.
   - Удаление фотографий.
   - Сбор и учёт лайков под фото.
   - Создание профиля и его редактирование.
   - Ещё одна бизнес-функция не упомянутая в техническом задании явно - это аутентификация пользователя.

   Выделенные функции полностью соответствуют возможным маршрутам пользователя на сайте.

   В соответствии со стратегией вертикальной нарезки микрофронтенды будут организованы вокруг бизнес-функций:
   - Загрузка фотографий - card-add-microfrontend
   - Удаление фотографий - card-del-microfrontend
   - Сбор и учёт лайков под фото - card-like-microfrontend
   - Создание профиля и его редактирование - profile-microfrontend
   - Аутентификация пользователя - auth-microfrontend 
   - Host-микрофронтенд - frontend

3. Выбор методов реализации, фреймворков, инструментов. 

   В соответствии со стратегией автономности команд технологический стек выбирается отдельно под каждый микрофронтенд.
Angular предоставляет максимум инструментов "из коробки", контроль типизации, обеспечивает надёжную среду для сложных проверок и работу в реальном времени.
Vue.js подходит для быстрой разработки и интеграции новых функциональностей с низким порогом входа.
React предлагает передовые решения по управлению состоянием и интерактивными компонентами, обеспечивает быструю загрузку элементов и изображений.

   В рассматриваемом проекте ни для одного из выделенных микрофронтендов не требуются сложные проверки и работа в реальном времени. Также пока не требуется создавать новые микрофронтенды с нуля. Но важны скорость загрузки элементов и изображений, а также возможность оперативного управления состоянием. Также стоит отметить, что имеющийся функционал написан на React. Поэтому для всех микрофронтендов в качестве фреймворка выбран именно React.

   Также выбран метод интеграции run-time, т.к. именно он, в отличие от build-time, позволяет динамически обновлять и разворачивать модули независимо.

   Для метода интеграции run-time выбрана клиентская композиция, т.к. именно она больше подходит, когда:
   - Приложение содержит много интерактивного контента, который изменяется в зависимости от взаимодействия с пользователем.
   - Приложение должно поддерживать независимое развёртывание отдельных модулей
   В то же время требования по SEO и оптимизации начальной загрузки страниц, которые могли бы обусловить необходимость серверной или гибридной сборки, отсутствуют.

4. Выбор инструмента для создания микрофронтендов.

   В качестве инструмента для создания микрофронтендов были рассмотрены два наиболее распространённых и развитых инструмента: Webpack Module Federation  и Single SPA. В виду того, что все микрофронтенды будут реализованы с использованием одного фреймворка (React), необходимость в Single SPA отсутствует, и можно исходить из экспертизы команды. В связи с чем выбран Webpack Module Federation.

5. Организация межмодульного взаимодействия.

   Все модули проекта используют данные текущего пользователя. В целях увеличения производительность стоит разделять эти данные между модулями и актуализировать непосредственно на клиентской стороне без необходимости обращаться за актуальными данными пользователя к бэкенду при переключении между компонентами.
К тому же, проект полностью управляется пользовательскими событиями, и требуется минимизировать связанность компонентов и обеспечить их независимое развертывание.
Поэтому наиболее подходящей стратегией межмодульного взаимодействия будет использование паттерна Pub/Sub.


## Уровень 2.

В результате разделения проекта по бизнес-функциям в соответствии со стратегией вертикальной нарезки были выделены следующие микрофронтенды:
- **auth-microfrontend (аутентификация пользователя).** Сюда вошли компоненты для управления входом в систему (Login.js), регистрации в системе (Register.js), уведомлений об успехе/неудаче при указанных операциях (InfoTooltip.js), связанные с ними элементы разметки, стили, изображения, код для взаимодействия с бэкендом (auth.js).
- **profile-microfrontend (создание профиля и его редактирование).** Сюда вошли компоненты для редактирования данных профиля и аватара пользователя (EditProfilePopup.js, EditAvatarPopup.js), общий компонент для всплывающих окон (PopupWithForm.js), связанные с ними элементы разметки, стили, изображения, код для взаимодействия с бэкендом (функции setUserInfo, setUserAvatar из api.js).
- **card-add-microfrontend (загрузка фотографий).** Сюда вошли компонент для создания карточки с фото и подписью (AddPlacePopup.js), общий компонент для всплывающих окон (PopupWithForm.js), связанные с ними элементы разметки, стили, изображения, код для взаимодействия с бэкендом (функция addCard из api.js). 
- **card-del-microfrontend (удаление фотографий).** Сюда вошёл код компонента карточки (Card.js), отвечающий за удаление карточки, связанные с ним элементы разметки, стили, изображения, код для взаимодействия с бэкендом (функция removeCard из api.js). Также сюда вошёл неиспользуемый (но, возможно, необходимый) элемент интерфейса для вывода предупреждения при удалении карточки `<PopupWithForm title="Вы уверены?" name="remove-card" buttonText="Да" />` и связанные с ним общий компонент для всплывающих окон (PopupWithForm.js) и стили.
- **card-like-microfrontend (сбор и учёт лайков под фото).** Сюда вошёл код компонента карточки (Card.js), отвечающий за установку снятия лайка и подсчёт лайков, связанные с ним элементы разметки, стили, изображения, код для взаимодействия с бэкендом (функция changeLikeCardStatus из api.js). - 
- **frontend (host-микрофронтенд).** В главном микрофронтенде остались компоненты, отвечающие за состояние текущего пользователя и компоновку приложения. 

Для запуска обновлённого приложения необходимо в консоли в каждой из папок auth-microfrontend, profile-microfrontend, card-add-microfrontend, card-del-microfrontend, card-like-microfrontend, frontend выполнить команды `npm install` и `npm start`. Либо выполнить в консоли в корне проекта команду `docker-compose -f compose-new.yaml up` для запуска всех микрофронтендов в docker-контейнерах.


## Уровень 3.

Реализованы все три уровня решения.


# Задание 2

Ссылка на архитектурную схему решения: https://drive.google.com/file/d/14wVeTga6ENRhSCNEAg-Vcs5z-lggLKEA/view?usp=drive_link

Для выделения компонентов монолитного приложения, которые должны быть извлечены, используется анализ бизнес-домена и технический анализ. Данные о производительности текущей системы отсутствуют, поэтому анализ показателей производительности применить нельзя.

1. В результате анализа бизнес-домена (Domain-Driven Design), выделены следующие компоненты.
   - **Управление пользователями**: управление регистрацией, аутентификацией, обработка данных пользователей.
   - **Товары и услуги**: все аспекты, связанные со списком товаров и услуг, их описание, привязку к профилю пользователя и торговой площадке. Т.к. работа с товарами и услугами ведётся однотипно, разделять их по отдельным компонентам не имеет смысла.
   - **Управление аукционами**: создание и редактирование аукционов, размещение заказов на товары и услуги на аукционах, проведение аукционов.
   - **Обработка заказов**: управление всем жизненным циклом заказа от оформления до оплаты.
   - **Обработка заявок**: работа с заявками клиентов. Заявки могут иметь различный тип (на регистрацию, на апелляцию, на техподдержку, на участие в аукционе), но их жизненный цикл практически одинаков: создание, регистрация (для некоторых типов), обработка. Будут различаться только действия сотрудников при обработке заявок.
   - **Аналитика и отчётность**: сбор и анализ данных об активности пользователей, заказах и продажах для создания отчётов и аналитических материалов. Вынесение этого компонента в отдельный микросервис также позволит избавить от паразитной нагрузки оперативные хранилища других компонентов.

2. В результате технического анализа, выделены следующие компоненты.
   - **Нотификации**. Для отправки уведомлений требуется взаимодействие с различными внешними сервисами (почтовые сервисы, сервисы SMS и PUSH уведомлений). Зависимость от доступности внешних сервисов также обуславливает необходимость организации очереди уведомлений на отправку и их асинхронной обработки.
   - **Платёжный шлюз**. Для оплаты заказов требуется сложное взаимодействие с различными внешними сервисами оплаты.

Для маршрутизации запросов в новые микросервисы используется **API-шлюз**.

При реализации транзакций, задействующих несколько микросервисов, используется паттерн Saga:

1. Регистрация пользователей (микросервисы **Управление пользователями**, **Обработка заявок**, **Нотификации**), создание аукциона (микросервисы **Управление аукционами**, **Товары и услуги**), участие в аукционе (микросервисы **Обработка заявок**, **Управление аукционами**, **Нотификации**), заказ товара или услуги (микросервисы **Обработки заказа**, **Управление аукционами**, **Нотификации**) используют паттерн Saga:хореография, т.к. каждый микросервис имеет всю необходимую информацию для следующей операции в транзакции.

2. Оплата заказа (микросервисы **Обработка заказов**, **Товары и услуги**, **Платёжный шлюз**, **Нотификации**) использует паттерн Saga:оркестрация, где оркестратором выступает **Платёжный шлюз**, т.к. это позволяет избежать передачи в сервисы избыточной информации только для выполнения последующих операций (например, после резервирования товара по Товар.ID в микросервисе **Товары и услуги** необходимо отправлять запросы в микросервис **Управление пользователями** по Пользователь.ID).

3. Транзакции, по которым собираются данные для аналитики (вход в систему, заказ товара или услуги, оплата заказа), также используют разновидность паттерна Saga:хореография - CDC (Change Data Capture), предусматривающие передачу данных в аналитическое хранилище непосредственно из оперативных СУБД.

Поскольку исследование конкретных технологий, которые стоит применить в рамках разделения системы на микросервисы, выходит за рамки требований к заданию, для всех микросервисов в качестве стека указан Python, а в качестве СУБД - PostgreSQL. Для микросервиса **Нотификации** в качества средства взаимодействия с другими микросервисами указана очередь сообщений (без конкретизации технологии).
Тем не менее, уже можно сформулировать общие предложения по стеку и технологиям:

1. В виду разделения системы на микросервисы необходимость в сложном синхронном веб-фреймворке Django отпадает. Поэтому можно использовать более легкие и производительные веб-фреймворки (например, FastAPI).

2. Для работы с данными в микросервисе **Аналитика и отчётность** больше подойдёт специализированная аналитическая СУБД (например, ClickHouse).

3. Для работы с данными в микросервисе **Обработка заявок** больше подойдёт высокодоступная NoSQL СУБД (например, MongoDB) в виду плоской структуры данных: каждая заявка описывается ID, описанием и набором атрибутов для поиска (Пользователь.ID, Торговая площадка.ID), необходимость в соединениях отсутствует.

4. Для управления задачами по отправке уведомлений в микросервисе **Нотификации** предлагается использовать очередь сообщений (в зависимости от планируемой нагрузки можно выбрать, например, RabbitMQ или Apache Kafka). 
